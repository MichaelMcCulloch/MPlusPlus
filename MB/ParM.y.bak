-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParM where
import AbsM
import LexM
import ErrM

}

%name pProg Prog
%name pBlock Block
%name pListDeclaration ListDeclaration
%name pDeclaration Declaration
%name pVarDeclaration VarDeclaration
%name pListVarSpec ListVarSpec
%name pVarSpec VarSpec
%name pListArrayDimension ListArrayDimension
%name pArrayDimension ArrayDimension
%name pType Type
%name pFunDeclaration FunDeclaration
%name pFunBlock FunBlock
%name pParamList ParamList
%name pListBasicDeclaration ListBasicDeclaration
%name pBasicDeclaration BasicDeclaration
%name pListBasicArrayDimension ListBasicArrayDimension
%name pBasicArrayDimension BasicArrayDimension
%name pDataDeclaration DataDeclaration
%name pConsDeclarations ConsDeclarations
%name pMoreConsDecl MoreConsDecl
%name pConsDecl ConsDecl
%name pTypeList TypeList
%name pMoreType MoreType
%name pProgramBody ProgramBody
%name pFunBody FunBody
%name pProgStmts ProgStmts
%name pProgStmt ProgStmt
%name pLocation Location
%name pCaseList CaseList
%name pMoreCase MoreCase
%name pCase Case
%name pVarList VarList
%name pVarList1 VarList1
%name pMoreVarList MoreVarList
%name pExpr Expr
%name pBintTerm BintTerm
%name pBintFactor BintFactor
%name pCompareOp CompareOp
%name pIntExpr IntExpr
%name pAddop Addop
%name pIntTerm IntTerm
%name pMulop Mulop
%name pIntFactor IntFactor
%name pModifierList ModifierList
%name pFunArgumentList FunArgumentList
%name pConsArgumentList ConsArgumentList
%name pArguments Arguments
%name pMoreArguments MoreArguments
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '=<' { PT _ (TS _ 14) }
  '=>' { PT _ (TS _ 15) }
  '>' { PT _ (TS _ 16) }
  '>=' { PT _ (TS _ 17) }
  '[' { PT _ (TS _ 18) }
  ']' { PT _ (TS _ 19) }
  'begin' { PT _ (TS _ 20) }
  'bool' { PT _ (TS _ 21) }
  'case' { PT _ (TS _ 22) }
  'ceil' { PT _ (TS _ 23) }
  'char' { PT _ (TS _ 24) }
  'data' { PT _ (TS _ 25) }
  'do' { PT _ (TS _ 26) }
  'else' { PT _ (TS _ 27) }
  'end' { PT _ (TS _ 28) }
  'float' { PT _ (TS _ 29) }
  'floor' { PT _ (TS _ 30) }
  'fun' { PT _ (TS _ 31) }
  'if' { PT _ (TS _ 32) }
  'int' { PT _ (TS _ 33) }
  'not' { PT _ (TS _ 34) }
  'of' { PT _ (TS _ 35) }
  'print' { PT _ (TS _ 36) }
  'read' { PT _ (TS _ 37) }
  'real' { PT _ (TS _ 38) }
  'return' { PT _ (TS _ 39) }
  'size' { PT _ (TS _ 40) }
  'then' { PT _ (TS _ 41) }
  'var' { PT _ (TS _ 42) }
  'while' { PT _ (TS _ 43) }
  '{' { PT _ (TS _ 44) }
  '|' { PT _ (TS _ 45) }
  '||' { PT _ (TS _ 46) }
  '}' { PT _ (TS _ 47) }

L_ident  { PT _ (TV $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_CID { PT _ (T_CID $$) }
L_BVAL { PT _ (T_BVAL $$) }


%%

Ident   :: { Ident }   : L_ident  { Ident $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
CID    :: { CID} : L_CID { CID ($1)}
BVAL    :: { BVAL} : L_BVAL { BVAL ($1)}

Prog :: { Prog }
Prog : Block { AbsM.P $1 }
Block :: { Block }
Block : ListDeclaration ProgramBody { AbsM.Prog (reverse $1) $2 }
ListDeclaration :: { [Declaration] }
ListDeclaration : {- empty -} { [] }
                | ListDeclaration Declaration ';' { flip (:) $1 $2 }
Declaration :: { Declaration }
Declaration : VarDeclaration { AbsM.VarDef $1 }
            | FunDeclaration { AbsM.FunDef $1 }
            | DataDeclaration { AbsM.DataDef $1 }
VarDeclaration :: { VarDeclaration }
VarDeclaration : 'var' ListVarSpec ':' Type { AbsM.VarDeclaration $2 $4 }
ListVarSpec :: { [VarSpec] }
ListVarSpec : {- empty -} { [] }
            | VarSpec { (:[]) $1 }
            | VarSpec ',' ListVarSpec { (:) $1 $3 }
VarSpec :: { VarSpec }
VarSpec : Ident ListArrayDimension { AbsM.VarSpec $1 (reverse $2) }
ListArrayDimension :: { [ArrayDimension] }
ListArrayDimension : {- empty -} { [] }
                   | ListArrayDimension ArrayDimension { flip (:) $1 $2 }
ArrayDimension :: { ArrayDimension }
ArrayDimension : '[' Expr ']' { AbsM.ArrDim $2 }
Type :: { Type }
Type : 'int' { AbsM.Tint }
     | 'real' { AbsM.Treal }
     | 'bool' { AbsM.Tbool }
     | 'char' { AbsM.Tchar }
     | Ident { AbsM.Tuser $1 }
FunDeclaration :: { FunDeclaration }
FunDeclaration : 'fun' Ident ParamList ':' Type '{' FunBlock '}' { AbsM.FunctionDec $2 $3 $5 $7 }
FunBlock :: { FunBlock }
FunBlock : ListDeclaration FunBody { AbsM.FunctionBlock (reverse $1) $2 }
ParamList :: { ParamList }
ParamList : '(' ListBasicDeclaration ')' { AbsM.ParameterList $2 }
ListBasicDeclaration :: { [BasicDeclaration] }
ListBasicDeclaration : {- empty -} { [] }
                     | BasicDeclaration { (:[]) $1 }
                     | BasicDeclaration ',' ListBasicDeclaration { (:) $1 $3 }
BasicDeclaration :: { BasicDeclaration }
BasicDeclaration : Ident ListBasicArrayDimension ':' Type { AbsM.BasicDeclaration $1 (reverse $2) $4 }
ListBasicArrayDimension :: { [BasicArrayDimension] }
ListBasicArrayDimension : {- empty -} { [] }
                        | ListBasicArrayDimension BasicArrayDimension { flip (:) $1 $2 }
BasicArrayDimension :: { BasicArrayDimension }
BasicArrayDimension : '[' ']' { AbsM.BArrDim }
DataDeclaration :: { DataDeclaration }
DataDeclaration : 'data' Ident '=' ConsDeclarations { AbsM.DataDeclaration $2 $4 }
ConsDeclarations :: { ConsDeclarations }
ConsDeclarations : ConsDecl MoreConsDecl { AbsM.ConsDeclarations $1 $2 }
MoreConsDecl :: { MoreConsDecl }
MoreConsDecl : '|' ConsDecl MoreConsDecl { AbsM.MCDList $2 $3 }
             | {- empty -} { AbsM.MCDEnd }
ConsDecl :: { ConsDecl }
ConsDecl : CID 'of' TypeList { AbsM.CTypeList $1 $3 }
         | CID { AbsM.CSimple $1 }
TypeList :: { TypeList }
TypeList : Type MoreType { AbsM.TList $1 $2 }
MoreType :: { MoreType }
MoreType : '*' Type MoreType { AbsM.MTList $2 $3 }
         | {- empty -} { AbsM.MTEnd }
ProgramBody :: { ProgramBody }
ProgramBody : 'begin' ProgStmts 'end' { AbsM.ProgBodyA $2 }
            | ProgStmts { AbsM.ProgBodyB $1 }
FunBody :: { FunBody }
FunBody : 'begin' ProgStmts 'return' Expr ';' 'end' { AbsM.FunBodyA $2 $4 }
        | ProgStmts 'return' Expr ';' { AbsM.FunBodyB $1 $3 }
ProgStmts :: { ProgStmts }
ProgStmts : ProgStmt ';' ProgStmts { AbsM.PSList $1 $3 }
          | {- empty -} { AbsM.PSEnd }
ProgStmt :: { ProgStmt }
ProgStmt : 'if' Expr 'then' ProgStmt 'else' ProgStmt { AbsM.PIf $2 $4 $6 }
         | 'while' Expr 'do' ProgStmt { AbsM.PWhile $2 $4 }
         | 'read' Location { AbsM.PRead $2 }
         | Location ':=' Expr { AbsM.PLocation $1 $3 }
         | 'print' Expr { AbsM.PPrint $2 }
         | '{' Block '}' { AbsM.PBlock $2 }
         | 'case' Expr 'of' '{' CaseList '}' { AbsM.PExpr $2 $5 }
Location :: { Location }
Location : Ident ListArrayDimension { AbsM.Location $1 (reverse $2) }
CaseList :: { CaseList }
CaseList : Case MoreCase { AbsM.Cases $1 $2 }
MoreCase :: { MoreCase }
MoreCase : '|' Case MoreCase { AbsM.MCList $2 $3 }
         | {- empty -} { AbsM.MCEnd }
Case :: { Case }
Case : CID VarList '=>' ProgStmt { AbsM.Case $1 $2 $4 }
VarList :: { VarList }
VarList : '(' VarList1 ')' { AbsM.VLList $2 }
        | {- empty -} { AbsM.VLEnd }
VarList1 :: { VarList }
VarList1 : Ident MoreVarList { AbsM.VarList $1 $2 }
MoreVarList :: { MoreVarList }
MoreVarList : ',' Ident MoreVarList { AbsM.MVLList $2 $3 }
            | {- empty -} { AbsM.MVLEnd }
Expr :: { Expr }
Expr : Expr '||' BintTerm { AbsM.BOr $1 $3 }
     | BintTerm { AbsM.BTerm $1 }
BintTerm :: { BintTerm }
BintTerm : BintTerm '&&' BintFactor { AbsM.BAnd $1 $3 }
         | BintFactor { AbsM.BFactor $1 }
BintFactor :: { BintFactor }
BintFactor : 'not' BintFactor { AbsM.BNot $2 }
           | IntExpr CompareOp IntExpr { AbsM.BCompare $1 $2 $3 }
           | IntExpr { AbsM.BExpr $1 }
CompareOp :: { CompareOp }
CompareOp : '=' { AbsM.CompEQ }
          | '<' { AbsM.CompLT }
          | '>' { AbsM.CompGT }
          | '=<' { AbsM.CompLEQ }
          | '>=' { AbsM.CompGEQ }
IntExpr :: { IntExpr }
IntExpr : IntExpr Addop IntTerm { AbsM.IntAdd $1 $2 $3 }
        | IntTerm { AbsM.IntTerm $1 }
Addop :: { Addop }
Addop : '+' { AbsM.Add } | '-' { AbsM.Sub }
IntTerm :: { IntTerm }
IntTerm : IntTerm Mulop IntFactor { AbsM.IntMul $1 $2 $3 }
        | IntFactor { AbsM.IntFactor $1 }
Mulop :: { Mulop }
Mulop : '*' { AbsM.Mult } | '/' { AbsM.Divide }
IntFactor :: { IntFactor }
IntFactor : '(' Expr ')' { AbsM.Expression $2 }
          | 'size' '(' Ident ListBasicArrayDimension ')' { AbsM.ListSize $3 (reverse $4) }
          | 'float' '(' Expr ')' { AbsM.ToFloat $3 }
          | 'floor' '(' Expr ')' { AbsM.FunFloor $3 }
          | 'ceil' '(' Expr ')' { AbsM.FunCeil $3 }
          | Ident ModifierList { AbsM.IDModList $1 $2 }
          | CID ConsArgumentList { AbsM.IData $1 $2 }
          | Integer { AbsM.Integer $1 }
          | Double { AbsM.Real $1 }
          | BVAL { AbsM.Boolean $1 }
          | Char { AbsM.Character $1 }
          | '-' IntFactor { AbsM.Negate $2 }
ModifierList :: { ModifierList }
ModifierList : FunArgumentList { AbsM.FunctionCall $1 }
             | ListArrayDimension { AbsM.ArrayAccess (reverse $1) }
FunArgumentList :: { FunArgumentList }
FunArgumentList : '(' Arguments ')' { AbsM.Args $2 }
ConsArgumentList :: { ConsArgumentList }
ConsArgumentList : FunArgumentList { AbsM.DataArguments $1 }
                 | {- empty -} { AbsM.DataArgumentsss }
Arguments :: { Arguments }
Arguments : Expr MoreArguments { AbsM.AList $1 $2 }
          | {- empty -} { AbsM.AEnd }
MoreArguments :: { MoreArguments }
MoreArguments : ',' Expr MoreArguments { AbsM.MAList $2 $3 }
              | {- empty -} { AbsM.MAEnd }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

