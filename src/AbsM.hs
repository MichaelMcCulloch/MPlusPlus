

module AbsM where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
newtype CID = CID String deriving (Eq, Ord, Show, Read)
newtype BVAL = BVAL String deriving (Eq, Ord, Show, Read)
data Prog = M Block
  deriving (Eq, Ord, Show, Read)

data Block = Program [Declaration] ProgramBody
  deriving (Eq, Ord, Show, Read)

data Declaration
    = Dec_Var VarDeclaration
    | Dec_Fun FunDeclaration
    | Dec_Data DataDeclaration
  deriving (Eq, Ord, Show, Read)

data VarDeclaration = D_Variable [VarSpec] Type
  deriving (Eq, Ord, Show, Read)

data VarSpec = V_Spec Ident [ArrayDimension]
  deriving (Eq, Ord, Show, Read)

data ArrayDimension = ArrDim Expr
  deriving (Eq, Ord, Show, Read)

data Type = T_Int | T_Real | T_Bool | T_Char | T_User Ident
  deriving (Eq, Ord, Show, Read)

data FunDeclaration = D_Function Ident ParamList Type FunBlock
  deriving (Eq, Ord, Show, Read)

data FunBlock = FunctionBlock [Declaration] FunBody
  deriving (Eq, Ord, Show, Read)

data ParamList = ParameterList [BasicDeclaration]
  deriving (Eq, Ord, Show, Read)

data BasicDeclaration = BasicDec Ident [BasicArrayDimension] Type
  deriving (Eq, Ord, Show, Read)

data BasicArrayDimension = B_ArrDim
  deriving (Eq, Ord, Show, Read)

data DataDeclaration = D_Data Ident [ConsDecl]
  deriving (Eq, Ord, Show, Read)

data ConsDecl = TypeComposition CID [Type] | TypeConstructor CID
  deriving (Eq, Ord, Show, Read)

data ProgramBody = P_Body [ProgStmt]
  deriving (Eq, Ord, Show, Read)

data FunBody = F_Body [ProgStmt] Expr
  deriving (Eq, Ord, Show, Read)

data ProgStmt
    = P_If Expr ProgStmt ProgStmt
    | P_While Expr ProgStmt
    | P_Read Location
    | P_Assign Location Expr
    | P_Print Expr
    | P_Block Block
    | P_Case Expr [Case]
  deriving (Eq, Ord, Show, Read)

data Location = L_Location Ident [ArrayDimension]
  deriving (Eq, Ord, Show, Read)

data Case = C_Case CID VarList ProgStmt
  deriving (Eq, Ord, Show, Read)

data VarList = VL_List [Ident] | VL_End
  deriving (Eq, Ord, Show, Read)

data Expr = B_Or Expr BintTerm | B_Term BintTerm
  deriving (Eq, Ord, Show, Read)

data BintTerm = B_And BintTerm BintFactor | B_Factor BintFactor
  deriving (Eq, Ord, Show, Read)

data BintFactor
    = B_Not BintFactor
    | B_Compare IntExpr CompareOp IntExpr
    | B_Expr IntExpr
  deriving (Eq, Ord, Show, Read)

data CompareOp = B_EQ | B_LT | B_GT | B_LE | B_GE
  deriving (Eq, Ord, Show, Read)

data IntExpr = Int_Add IntExpr Addop IntTerm | Int_Term IntTerm
  deriving (Eq, Ord, Show, Read)

data Addop = Op_Add | Op_Sub
  deriving (Eq, Ord, Show, Read)

data IntTerm
    = Int_Mul IntTerm Mulop IntFactor | Int_Factor IntFactor
  deriving (Eq, Ord, Show, Read)

data Mulop = Op_Mult | Op_Divide
  deriving (Eq, Ord, Show, Read)

data IntFactor
    = IF_Expression Expr
    | IF_Size Ident [BasicArrayDimension]
    | IF_Float Expr
    | IF_Floor Expr
    | IF_Ceil Expr
    | IF_ID Ident ModifierList
    | IF_Data CID ConsArgumentList
    | IF_Integer Integer
    | IF_Real Double
    | IF_Boolean BVAL
    | IF_Character Char
    | IF_Negate IntFactor
  deriving (Eq, Ord, Show, Read)

data ModifierList
    = Mod_CallParams FunArgumentList | Mod_Array [ArrayDimension]
  deriving (Eq, Ord, Show, Read)

data FunArgumentList = F_Args [Expr]
  deriving (Eq, Ord, Show, Read)

data ConsArgumentList = CAL_Arguments FunArgumentList | CAL_NoArgs
  deriving (Eq, Ord, Show, Read)

