module SkelM where

-- Haskell module generated by the BNF converter
import qualified AST as A
import AbsM

transIdent :: Ident ->
transIdent x = case x of
  Ident string ->
transCID :: CID ->
transCID x = case x of
  CID string ->
transBVAL :: BVAL ->
transBVAL x = case x of
  BVAL string ->
transProg :: Prog ->
transProg x = case x of
  Program block ->
transBlock :: Block ->
transBlock x = case x of
  Prog declarations programbody -> A.M_block (map transDeclaration declarations, transProgramBody programbody)
transDeclaration :: Declaration ->
transDeclaration x = case x of
  VarDef vardeclaration ->
  FunDef fundeclaration ->
  DataDef datadeclaration ->
transVarDeclaration :: VarDeclaration ->
transVarDeclaration x = case x of
  VarDeclaration varspecs type_ ->
transVarSpec :: VarSpec ->
transVarSpec x = case x of
  VarSpec ident arraydimensions ->
transArrayDimension :: ArrayDimension ->
transArrayDimension x = case x of
  ArrDim expr ->
transType :: Type ->
transType x = case x of
  Tint ->
  Treal ->
  Tbool ->
  Tchar ->
  Tuser ident ->
transFunDeclaration :: FunDeclaration ->
transFunDeclaration x = case x of
  FunctionDec ident paramlist type_ funblock ->
transFunBlock :: FunBlock ->
transFunBlock x = case x of
  FunctionBlock declarations funbody ->
transParamList :: ParamList ->
transParamList x = case x of
  ParameterList basicdeclarations ->
transBasicDeclaration :: BasicDeclaration ->
transBasicDeclaration x = case x of
  BasicDeclaration ident basicarraydimensions type_ ->
transBasicArrayDimension :: BasicArrayDimension ->
transBasicArrayDimension x = case x of
  BArrDim ->
transDataDeclaration :: DataDeclaration ->
transDataDeclaration x = case x of
  DataDeclaration ident consdecls ->
transConsDecl :: ConsDecl ->
transConsDecl x = case x of
  TypeComposition cid types ->
  Constructor cid ->
transProgramBody :: ProgramBody ->
transProgramBody x = case x of
  ProgBodyA progstmts ->
  ProgBodyB progstmts ->
transFunBody :: FunBody ->
transFunBody x = case x of
  FunBodyA progstmts expr ->
  FunBodyB progstmts expr ->
transProgStmt :: ProgStmt ->
transProgStmt x = case x of
  PIf expr progstmt1 progstmt2 ->
  PWhile expr progstmt ->
  PRead location ->
  PAssign location expr ->
  PPrint expr ->
  PBlock block ->
  PCase expr cases ->
transLocation :: Location ->
transLocation x = case x of
  Location ident arraydimensions ->
transCase :: Case ->
transCase x = case x of
  Case cid varlist progstmt ->
transVarList :: VarList ->
transVarList x = case x of
  VLList idents ->
  VLEnd ->
transExpr :: Expr ->
transExpr x = case x of
  BOr expr bintterm ->
  BTerm bintterm ->
transBintTerm :: BintTerm ->
transBintTerm x = case x of
  BAnd bintterm bintfactor ->
  BFactor bintfactor ->
transBintFactor :: BintFactor ->
transBintFactor x = case x of
  BNot bintfactor ->
  BCompare intexpr1 compareop intexpr2 ->
  BExpr intexpr ->
transCompareOp :: CompareOp ->
transCompareOp x = case x of
  CompEQ ->
  CompLT ->
  CompGT ->
  CompLEQ ->
  CompGEQ ->
transIntExpr :: IntExpr ->
transIntExpr x = case x of
  IntAdd intexpr addop intterm ->
  IntTerm intterm ->
transAddop :: Addop ->
transAddop x = case x of
  Add -> A.M_add
  Sub -> A.M_sub
transIntTerm :: IntTerm ->
transIntTerm x = case x of
  IntMul intterm mulop intfactor ->
  IntFactor intfactor ->
transMulop :: Mulop ->
transMulop x = case x of
  Mult -> A.M_mul
  Divide -> A.M_div
transIntFactor :: IntFactor ->
transIntFactor x = case x of
  Expression expr ->
  Size ident basicarraydimensions -> M_size (transIdent, length basicarraydimensions)
  Float expr ->
  Floor expr ->
  Ceil expr ->
  ID ident modifierlist ->
  Data cid consargumentlist ->
  Integer integer -> A.M_ival integer
  Real double -> A.M_rval double
  Boolean bval -> A.M_bval (transBVAL bval)
  Character char -> A.M_char char
  Negate intfactor -> M_neg (transIntFactor intfactor)
transModifierList :: ModifierList ->
transModifierList x = case x of
  FunctionCall funargumentlist ->
  ArrayAccess arraydimensions ->
transFunArgumentList :: FunArgumentList ->
transFunArgumentList x = case x of
  Args exprs ->
transConsArgumentList :: ConsArgumentList ->
transConsArgumentList x = case x of
  DataArguments funargumentlist ->
  NoArguments ->
