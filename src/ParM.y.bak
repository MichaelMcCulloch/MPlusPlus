-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParM where
import AbsM
import LexM
import ErrM

}

%name pProg Prog
%name pBlock Block
%name pDeclaration Declaration
%name pVarDeclaration VarDeclaration
%name pVarSpec VarSpec
%name pArrayDimension ArrayDimension
%name pType Type
%name pFunDeclaration FunDeclaration
%name pFunBlock FunBlock
%name pParamList ParamList
%name pBasicDeclaration BasicDeclaration
%name pBasicArrayDimension BasicArrayDimension
%name pDataDeclaration DataDeclaration
%name pConsDecl ConsDecl
%name pProgramBody ProgramBody
%name pFunBody FunBody
%name pProgStmt ProgStmt
%name pLocation Location
%name pCase Case
%name pVarList VarList
%name pExpr Expr
%name pBintTerm BintTerm
%name pBintFactor BintFactor
%name pCompareOp CompareOp
%name pIntExpr IntExpr
%name pAddop Addop
%name pIntTerm IntTerm
%name pMulop Mulop
%name pIntFactor IntFactor
%name pModifierList ModifierList
%name pFunArgumentList FunArgumentList
%name pConsArgumentList ConsArgumentList
%name pListVarSpec ListVarSpec
%name pListArrayDimension ListArrayDimension
%name pListBasicDeclaration ListBasicDeclaration
%name pListBasicArrayDimension ListBasicArrayDimension
%name pListConsDecl ListConsDecl
%name pListType ListType
%name pListCase ListCase
%name pListPIdent ListPIdent
%name pListExpr ListExpr
%name pListDeclaration ListDeclaration
%name pListProgStmt ListProgStmt
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '&&' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':=' { PT _ (TS _ 10) }
  ';' { PT _ (TS _ 11) }
  '<' { PT _ (TS _ 12) }
  '=' { PT _ (TS _ 13) }
  '=<' { PT _ (TS _ 14) }
  '=>' { PT _ (TS _ 15) }
  '>' { PT _ (TS _ 16) }
  '>=' { PT _ (TS _ 17) }
  '[' { PT _ (TS _ 18) }
  ']' { PT _ (TS _ 19) }
  'begin' { PT _ (TS _ 20) }
  'bool' { PT _ (TS _ 21) }
  'case' { PT _ (TS _ 22) }
  'ceil' { PT _ (TS _ 23) }
  'char' { PT _ (TS _ 24) }
  'data' { PT _ (TS _ 25) }
  'do' { PT _ (TS _ 26) }
  'else' { PT _ (TS _ 27) }
  'end' { PT _ (TS _ 28) }
  'float' { PT _ (TS _ 29) }
  'floor' { PT _ (TS _ 30) }
  'fun' { PT _ (TS _ 31) }
  'if' { PT _ (TS _ 32) }
  'int' { PT _ (TS _ 33) }
  'not' { PT _ (TS _ 34) }
  'of' { PT _ (TS _ 35) }
  'print' { PT _ (TS _ 36) }
  'read' { PT _ (TS _ 37) }
  'real' { PT _ (TS _ 38) }
  'return' { PT _ (TS _ 39) }
  'size' { PT _ (TS _ 40) }
  'then' { PT _ (TS _ 41) }
  'var' { PT _ (TS _ 42) }
  'while' { PT _ (TS _ 43) }
  '{' { PT _ (TS _ 44) }
  '|' { PT _ (TS _ 45) }
  '||' { PT _ (TS _ 46) }
  '}' { PT _ (TS _ 47) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_CID { PT _ (T_CID _) }
L_BVAL { PT _ (T_BVAL _) }
L_PIdent { PT _ (T_PIdent _) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
CID    :: { CID} : L_CID { CID (mkPosToken $1)}
BVAL    :: { BVAL} : L_BVAL { BVAL (mkPosToken $1)}
PIdent    :: { PIdent} : L_PIdent { PIdent (mkPosToken $1)}

Prog :: { Prog }
Prog : Block { AbsM.M $1 }
Block :: { Block }
Block : ListDeclaration ProgramBody { AbsM.Program (reverse $1) $2 }
Declaration :: { Declaration }
Declaration : VarDeclaration { AbsM.Dec_Var $1 }
            | FunDeclaration { AbsM.Dec_Fun $1 }
            | DataDeclaration { AbsM.Dec_Data $1 }
VarDeclaration :: { VarDeclaration }
VarDeclaration : 'var' ListVarSpec ':' Type { AbsM.D_Variable $2 $4 }
VarSpec :: { VarSpec }
VarSpec : PIdent ListArrayDimension { AbsM.V_Spec $1 (reverse $2) }
ArrayDimension :: { ArrayDimension }
ArrayDimension : '[' Expr ']' { AbsM.ArrDim $2 }
Type :: { Type }
Type : 'int' { AbsM.T_Int }
     | 'real' { AbsM.T_Real }
     | 'bool' { AbsM.T_Bool }
     | 'char' { AbsM.T_Char }
     | PIdent { AbsM.T_User $1 }
FunDeclaration :: { FunDeclaration }
FunDeclaration : 'fun' PIdent ParamList ':' Type '{' FunBlock '}' { AbsM.D_Function $2 $3 $5 $7 }
FunBlock :: { FunBlock }
FunBlock : ListDeclaration FunBody { AbsM.FunctionBlock (reverse $1) $2 }
ParamList :: { ParamList }
ParamList : '(' ListBasicDeclaration ')' { AbsM.ParameterList $2 }
BasicDeclaration :: { BasicDeclaration }
BasicDeclaration : PIdent ListBasicArrayDimension ':' Type { AbsM.BasicDec $1 (reverse $2) $4 }
BasicArrayDimension :: { BasicArrayDimension }
BasicArrayDimension : '[' ']' { AbsM.B_ArrDim }
DataDeclaration :: { DataDeclaration }
DataDeclaration : 'data' PIdent '=' ListConsDecl { AbsM.D_Data $2 $4 }
ConsDecl :: { ConsDecl }
ConsDecl : CID 'of' ListType { AbsM.TypeComposition $1 $3 }
         | CID { AbsM.TypeConstructor $1 }
ProgramBody :: { ProgramBody }
ProgramBody : 'begin' ListProgStmt 'end' { AbsM.P_Body (reverse $2) }
            | ListProgStmt { AbsM.P_Body (reverse $1) }
FunBody :: { FunBody }
FunBody : 'begin' ListProgStmt 'return' Expr ';' 'end' { AbsM.F_Body (reverse $2) $4 }
        | ListProgStmt 'return' Expr ';' { AbsM.F_Body (reverse $1) $3 }
ProgStmt :: { ProgStmt }
ProgStmt : 'if' Expr 'then' ProgStmt 'else' ProgStmt { AbsM.P_If $2 $4 $6 }
         | 'while' Expr 'do' ProgStmt { AbsM.P_While $2 $4 }
         | 'read' Location { AbsM.P_Read $2 }
         | Location ':=' Expr { AbsM.P_Assign $1 $3 }
         | 'print' Expr { AbsM.P_Print $2 }
         | '{' Block '}' { AbsM.P_Block $2 }
         | 'case' Expr 'of' '{' ListCase '}' { AbsM.P_Case $2 $5 }
Location :: { Location }
Location : PIdent ListArrayDimension { AbsM.L_Location $1 (reverse $2) }
Case :: { Case }
Case : CID VarList '=>' ProgStmt { AbsM.C_Case $1 $2 $4 }
VarList :: { VarList }
VarList : '(' ListPIdent ')' { AbsM.VL_List $2 }
        | {- empty -} { AbsM.VL_End }
Expr :: { Expr }
Expr : Expr '||' BintTerm { AbsM.B_Or $1 $3 }
     | BintTerm { AbsM.B_Term $1 }
BintTerm :: { BintTerm }
BintTerm : BintTerm '&&' BintFactor { AbsM.B_And $1 $3 }
         | BintFactor { AbsM.B_Factor $1 }
BintFactor :: { BintFactor }
BintFactor : 'not' BintFactor { AbsM.B_Not $2 }
           | IntExpr CompareOp IntExpr { AbsM.B_Compare $1 $2 $3 }
           | IntExpr { AbsM.B_Expr $1 }
CompareOp :: { CompareOp }
CompareOp : '=' { AbsM.B_EQ }
          | '<' { AbsM.B_LT }
          | '>' { AbsM.B_GT }
          | '=<' { AbsM.B_LE }
          | '>=' { AbsM.B_GE }
IntExpr :: { IntExpr }
IntExpr : IntExpr Addop IntTerm { AbsM.Int_Add $1 $2 $3 }
        | IntTerm { AbsM.Int_Term $1 }
Addop :: { Addop }
Addop : '+' { AbsM.Op_Add } | '-' { AbsM.Op_Sub }
IntTerm :: { IntTerm }
IntTerm : IntTerm Mulop IntFactor { AbsM.Int_Mul $1 $2 $3 }
        | IntFactor { AbsM.Int_Factor $1 }
Mulop :: { Mulop }
Mulop : '*' { AbsM.Op_Mult } | '/' { AbsM.Op_Divide }
IntFactor :: { IntFactor }
IntFactor : '(' Expr ')' { AbsM.IF_Expression $2 }
          | 'size' '(' PIdent ListBasicArrayDimension ')' { AbsM.IF_Size $3 (reverse $4) }
          | 'float' '(' Expr ')' { AbsM.IF_Float $3 }
          | 'floor' '(' Expr ')' { AbsM.IF_Floor $3 }
          | 'ceil' '(' Expr ')' { AbsM.IF_Ceil $3 }
          | PIdent ModifierList { AbsM.IF_ID $1 $2 }
          | CID ConsArgumentList { AbsM.IF_Data $1 $2 }
          | Integer { AbsM.IF_Integer $1 }
          | Double { AbsM.IF_Real $1 }
          | BVAL { AbsM.IF_Boolean $1 }
          | Char { AbsM.IF_Character $1 }
          | '-' IntFactor { AbsM.IF_Negate $2 }
ModifierList :: { ModifierList }
ModifierList : FunArgumentList { AbsM.Mod_CallParams $1 }
             | ListArrayDimension { AbsM.Mod_Array (reverse $1) }
FunArgumentList :: { FunArgumentList }
FunArgumentList : '(' ListExpr ')' { AbsM.F_Args $2 }
ConsArgumentList :: { ConsArgumentList }
ConsArgumentList : FunArgumentList { AbsM.CAL_Arguments $1 }
                 | {- empty -} { AbsM.CAL_NoArgs }
ListVarSpec :: { [VarSpec] }
ListVarSpec : {- empty -} { [] }
            | VarSpec { (:[]) $1 }
            | VarSpec ',' ListVarSpec { (:) $1 $3 }
ListArrayDimension :: { [ArrayDimension] }
ListArrayDimension : {- empty -} { [] }
                   | ListArrayDimension ArrayDimension { flip (:) $1 $2 }
ListBasicDeclaration :: { [BasicDeclaration] }
ListBasicDeclaration : {- empty -} { [] }
                     | BasicDeclaration { (:[]) $1 }
                     | BasicDeclaration ',' ListBasicDeclaration { (:) $1 $3 }
ListBasicArrayDimension :: { [BasicArrayDimension] }
ListBasicArrayDimension : {- empty -} { [] }
                        | ListBasicArrayDimension BasicArrayDimension { flip (:) $1 $2 }
ListConsDecl :: { [ConsDecl] }
ListConsDecl : ConsDecl { (:[]) $1 }
             | ConsDecl '|' ListConsDecl { (:) $1 $3 }
ListType :: { [Type] }
ListType : Type { (:[]) $1 } | Type '*' ListType { (:) $1 $3 }
ListCase :: { [Case] }
ListCase : Case { (:[]) $1 } | Case '|' ListCase { (:) $1 $3 }
ListPIdent :: { [PIdent] }
ListPIdent : PIdent { (:[]) $1 }
           | PIdent ',' ListPIdent { (:) $1 $3 }
ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }
ListDeclaration :: { [Declaration] }
ListDeclaration : {- empty -} { [] }
                | ListDeclaration Declaration ';' { flip (:) $1 $2 }
ListProgStmt :: { [ProgStmt] }
ListProgStmt : {- empty -} { [] }
             | ListProgStmt ProgStmt ';' { flip (:) $1 $2 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

