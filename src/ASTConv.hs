module ASTConv where

-- Haskell module generated by the BNF converter
import qualified AST as A
import AbsM

transIdent :: Ident -> String
transIdent x = case x of
  Ident string -> string
transCID :: CID -> String
transCID x = case x of
  CID string -> string
transBVAL :: BVAL -> Bool
transBVAL x = case x of
  BVAL string -> string == "true"
transProg :: Prog -> A.M_prog
transProg x = case x of
  M block -> A.M_prog (ds, ss) where
    (A.M_block (ds, ss)) = transBlock block
transBlock :: Block -> A.M_stmt
transBlock x = case x of
  Program declarations programbody -> A.M_block (concatMap transDeclaration declarations, transProgramBody programbody)
transDeclaration :: Declaration -> [A.M_decl]
transDeclaration x = case x of
  Dec_Var vardeclaration -> transVarDeclaration vardeclaration
  Dec_Fun fundeclaration -> [transFunDeclaration fundeclaration]
  Dec_Data datadeclaration -> [transDataDeclaration datadeclaration]
transVarDeclaration :: VarDeclaration -> [A.M_decl]
transVarDeclaration x = case x of
  D_Variable varspecs type_ -> map (\v -> transVarSpec v type_) varspecs
transVarSpec :: VarSpec -> Type -> A.M_decl
transVarSpec x type_ = case x of
  V_Spec ident arraydimensions -> A.M_var (transIdent ident, map transArrayDimension arraydimensions, transType type_)
transArrayDimension :: ArrayDimension -> A.M_expr
transArrayDimension x = case x of
  ArrDim expr -> transExpr expr
transType :: Type -> A.M_type
transType x = case x of
  T_Int -> A.M_int
  T_Real -> A.M_real
  T_Bool -> A.M_bool
  T_Char -> A.M_char
  T_User ident -> A.M_type (transIdent ident)
transFunDeclaration :: FunDeclaration -> A.M_decl
transFunDeclaration x = case x of
  D_Function ident paramlist type_ funblock ->
    A.M_fun (transIdent ident, transParamList paramlist, transType type_, ds, ss) where
      (A.M_block (ds, ss)) = transFunBlock funblock
transFunBlock :: FunBlock -> A.M_stmt
transFunBlock x = case x of
  FunctionBlock declarations funbody -> A.M_block (concatMap transDeclaration declarations, transFunBody funbody)
transParamList :: ParamList -> [(String, Int, A.M_type)]
transParamList x = case x of
  ParameterList basicdeclarations -> map transBasicDeclaration basicdeclarations
transBasicDeclaration :: BasicDeclaration ->(String, Int, A.M_type)
transBasicDeclaration x = case x of
  BasicDec ident basicarraydimensions type_ -> (transIdent ident, length basicarraydimensions, transType type_)
transBasicArrayDimension :: BasicArrayDimension -> String
transBasicArrayDimension x = case x of
  B_ArrDim -> error "B_ArrDim"
transDataDeclaration :: DataDeclaration -> A.M_decl
transDataDeclaration x = case x of
  D_Data ident consdecls -> A.M_data (transIdent ident, map transConsDecl consdecls)
transConsDecl :: ConsDecl -> (String, [A.M_type])
transConsDecl x = case x of
  TypeComposition cid types -> (transCID cid, map transType types)
  TypeConstructor cid -> (transCID cid, [])
transProgramBody :: ProgramBody -> [A.M_stmt]
transProgramBody x = case x of
  P_Body progstmts -> map transProgStmt progstmts
transFunBody :: FunBody -> [A.M_stmt]
transFunBody x = case x of
  F_Body progstmts expr -> map transProgStmt progstmts ++ [A.M_return (transExpr expr)]
transProgStmt :: ProgStmt -> A.M_stmt
transProgStmt x = case x of
  P_If expr progstmt1 progstmt2 -> A.M_cond (transExpr expr, transProgStmt progstmt1, transProgStmt progstmt2)
  P_While expr progstmt -> A.M_while (transExpr expr, transProgStmt progstmt)
  P_Read location -> A.M_read (transLocation location)
  P_Assign location expr -> A.M_ass (v, loc, eval) where
    (v, loc) = transLocation location
    eval = transExpr expr
  P_Print expr -> A.M_print (transExpr expr)
  P_Block block -> transBlock block
  P_Case expr cases -> A.M_case (transExpr expr, map transCase cases)
transLocation :: Location -> (String, [A.M_expr])
transLocation x = case x of
  L_Location ident arraydimensions -> (transIdent ident, map transArrayDimension arraydimensions)
transCase :: Case -> (String,[String],A.M_stmt)
transCase x = case x of
  C_Case cid varlist progstmt -> (transCID cid, transVarList varlist, transProgStmt progstmt)
transVarList :: VarList -> [String]
transVarList x = case x of
  VL_List idents -> map transIdent idents
  VL_End -> []
transExpr :: Expr -> A.M_expr
transExpr x = case x of
  B_Or expr bintterm -> A.M_app (A.M_or, transExpr expr:[transBintTerm bintterm])
  B_Term bintterm -> transBintTerm bintterm
transBintTerm :: BintTerm -> A.M_expr
transBintTerm x = case x of
  B_And bintterm bintfactor -> A.M_app (A.M_and, transBintTerm bintterm:[transBintFactor bintfactor])
  B_Factor bintfactor -> transBintFactor bintfactor
transBintFactor :: BintFactor -> A.M_expr
transBintFactor x = case x of
  B_Not bintfactor -> A.M_app (A.M_not, [transBintFactor bintfactor])
  B_Compare intexpr1 compareop intexpr2 -> A.M_app (transCompareOp compareop, transIntExpr intexpr1 : [transIntExpr intexpr2])
  B_Expr intexpr -> transIntExpr intexpr
transCompareOp :: CompareOp -> A.M_operation
transCompareOp x = case x of
  B_EQ -> A.M_eq
  B_LT -> A.M_lt
  B_GT -> A.M_gt
  B_LE -> A.M_le
  B_GE -> A.M_ge
transIntExpr :: IntExpr -> A.M_expr
transIntExpr x = case x of
  Int_Add intexpr addop intterm -> A.M_app (transAddop addop, transIntExpr intexpr : [transIntTerm intterm])
  Int_Term intterm -> transIntTerm intterm
transAddop :: Addop -> A.M_operation
transAddop x = case x of
  Op_Add -> A.M_add
  Op_Sub -> A.M_sub
transIntTerm :: IntTerm -> A.M_expr
transIntTerm x = case x of
  Int_Mul intterm mulop intfactor -> A.M_app (transMulop mulop, transIntTerm intterm : [transIntFactor intfactor])
  Int_Factor intfactor -> transIntFactor intfactor
transMulop :: Mulop -> A.M_operation
transMulop x = case x of
  Op_Mult -> A.M_mul
  Op_Divide -> A.M_div
transIntFactor :: IntFactor -> A.M_expr
transIntFactor x = case x of
  IF_Expression expr -> transExpr expr
  IF_Size ident basicarraydimensions -> A.M_size (transIdent ident, length basicarraydimensions)
  IF_Float expr -> A.M_app ( A.M_float, [transExpr expr])
  IF_Floor expr -> A.M_app ( A.M_floor, [transExpr expr])
  IF_Ceil expr -> A.M_app ( A.M_ceil, [transExpr expr])
  IF_ID ident modifierlist ->
    case modifierlist of
      Mod_CallParams _ -> A.M_app (A.M_fn (transIdent ident), transModifierList modifierlist)
      Mod_Array _ ->  A.M_id (transIdent ident, transModifierList modifierlist)--if modlist is ardim :ID, else FN
  IF_Data cid consargumentlist -> A.M_app (A.M_cid (transCID cid), transConsArgumentList consargumentlist)
  IF_Integer integer -> A.M_ival integer
  IF_Real double -> A.M_rval double
  IF_Boolean bval -> A.M_bval (transBVAL bval)
  IF_Character char -> A.M_cval char
  IF_Negate intfactor -> A.M_app (A.M_neg, [transIntFactor intfactor])
transModifierList :: ModifierList -> [A.M_expr]
transModifierList x = case x of
  Mod_CallParams funargumentlist -> transFunArgumentList funargumentlist
  Mod_Array arraydimensions -> map transArrayDimension arraydimensions
transFunArgumentList :: FunArgumentList ->[A.M_expr]
transFunArgumentList x = case x of
  F_Args exprs -> map transExpr exprs
transConsArgumentList :: ConsArgumentList ->[A.M_expr]
transConsArgumentList x = case x of
  CAL_Arguments funargumentlist -> transFunArgumentList funargumentlist
  CAL_NoArgs -> []
